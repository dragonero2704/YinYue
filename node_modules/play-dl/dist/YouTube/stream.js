"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stream_from_info = exports.stream = exports.StreamType = void 0;
const source_1 = __importDefault(require("got/dist/source"));
const _1 = require(".");
const LiveStream_1 = require("./classes/LiveStream");
var StreamType;
(function (StreamType) {
    StreamType["Arbitrary"] = "arbitrary";
    StreamType["Raw"] = "raw";
    StreamType["OggOpus"] = "ogg/opus";
    StreamType["WebmOpus"] = "webm/opus";
    StreamType["Opus"] = "opus";
})(StreamType = exports.StreamType || (exports.StreamType = {}));
function parseAudioFormats(formats) {
    let result = [];
    formats.forEach((format) => {
        let type = format.mimeType;
        if (type.startsWith('audio')) {
            format.codec = type.split('codecs="')[1].split('"')[0];
            format.container = type.split('audio/')[1].split(';')[0];
            result.push(format);
        }
    });
    return result;
}
async function stream(url, cookie) {
    let info = await _1.video_info(url, cookie);
    let final = [];
    let type;
    if (info.LiveStreamData.isLive === true && info.LiveStreamData.hlsManifestUrl !== null) {
        return live_stream(info);
    }
    let response = await source_1.default(info.format[info.format.length - 1].url, {
        headers: {
            "range": `bytes=0-1`
        }
    });
    if (response.statusCode >= 400) {
        return await stream(info.video_details.url);
    }
    let audioFormat = parseAudioFormats(info.format);
    let opusFormats = filterFormat(audioFormat, "opus");
    if (opusFormats.length === 0) {
        type = StreamType.Arbitrary;
        final.push(audioFormat[audioFormat.length - 1]);
    }
    else {
        type = StreamType.WebmOpus;
        final.push(opusFormats[opusFormats.length - 1]);
    }
    if (final.length === 0) {
        type = StreamType.Arbitrary;
        final.push(info.format[info.format.length - 1]);
    }
    return new LiveStream_1.Stream(final[0].url, type, info.video_details.durationInSec);
}
exports.stream = stream;
async function stream_from_info(info) {
    let final = [];
    let type;
    if (info.LiveStreamData.isLive === true && info.LiveStreamData.hlsManifestUrl !== null) {
        return live_stream(info);
    }
    let response = await source_1.default(info.format[info.format.length - 1].url, {
        headers: {
            "range": `bytes=0-1`
        }
    });
    if (response.statusCode >= 400) {
        return await stream(info.video_details.url);
    }
    let audioFormat = parseAudioFormats(info.format);
    let opusFormats = filterFormat(audioFormat, "opus");
    if (opusFormats.length === 0) {
        type = StreamType.Arbitrary;
        final.push(audioFormat[audioFormat.length - 1]);
    }
    else {
        type = StreamType.WebmOpus;
        final.push(opusFormats[opusFormats.length - 1]);
    }
    if (final.length === 0) {
        type = StreamType.Arbitrary;
        final.push(info.format[info.format.length - 1]);
    }
    return new LiveStream_1.Stream(final[0].url, type, info.video_details.durationInSec);
}
exports.stream_from_info = stream_from_info;
function filterFormat(formats, codec) {
    let result = [];
    formats.forEach((format) => {
        if (format.codec === codec)
            result.push(format);
    });
    return result;
}
function live_stream(info) {
    let stream;
    if (info.video_details.durationInSec === '0') {
        stream = new LiveStream_1.LiveStreaming(info.LiveStreamData.dashManifestUrl, info.format[info.format.length - 1].targetDurationSec);
    }
    else {
        stream = new LiveStream_1.LiveEnded(info.LiveStreamData.dashManifestUrl);
    }
    return stream;
}
//# sourceMappingURL=stream.js.map